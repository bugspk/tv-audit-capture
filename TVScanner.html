<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>TV Audit – Scan & Save as &lt;serial&gt;.jpg</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root { --pad:14px; --muted:#555; --btn:#2d6cdf; --ok:#0a0; --err:#d00; }
  body { font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin:0; }
  .wrap { max-width:520px; margin:auto; padding:var(--pad); }
  h2 { margin:0 0 10px 0; }
  label { font-weight:600; display:block; margin:12px 0 6px; }
  input[type="text"] { width:100%; padding:10px; font-size:18px; border:1px solid #ccc; border-radius:8px; }
  button { padding:10px 14px; font-size:16px; border:0; border-radius:10px; background:var(--btn); color:#fff; }
  button.secondary { background:#777; }
  button.ghost { background:#eee; color:#222; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .actions { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:10px; }
  video { width:100%; border-radius:8px; background:#000; display:none; }
  #msg { margin-top:10px; font-size:14px; }
  .tips { margin-top:12px; color:var(--muted); font-size:12px; }
  details { margin:6px 0 10px; }
  summary { cursor:pointer; color:#333; font-weight:600; }
  summary::marker { color:#888; }
  ol { color:#555; line-height:1.45; padding-left:20px; margin:8px 0 0; }
  .fileinfo { margin-top:8px; font-size:13px; color:#333; display:none; }
  .fileinfo .name { font-weight:600; }
  .preview { margin-top:6px; }
  .preview img { max-width:100%; max-height:160px; border-radius:8px; display:block; }

  /* Camera controls overlay */
  .camToolbar {
    display:none;
    gap:8px; align-items:center; flex-wrap:wrap;
    margin:8px 0 0;
  }
  .camToolbar .group {
    display:flex; gap:6px; align-items:center;
    background:#f5f5f5; border-radius:8px; padding:6px 8px;
  }
  .camToolbar label { margin:0; font-weight:600; font-size:12px; color:#333; }
  .camToolbar input[type="range"] { width:140px; }
</style>
</head>
<body>
<div class="wrap">
  <h2>Serial Scanner v0.92</h2>

  <details>
    <summary>How to use (tap to expand)</summary>
    <ol>
      <li>Tap <b>Scan</b> (or type Serial). You can now <b>tap on the preview to focus</b> and use <b>zoom/AF/torch</b> (if supported).</li>
      <li>Tap <b>Take Photo</b>, then <b>OK</b>. Filename/thumbnail show below.</li>
      <li>Tap <b>Save as JPG</b> to download <code>&lt;serial&gt;.jpg</code> (downscaled; memory-safe).</li>
    </ol>
  </details>

  <label>Serial</label>
  <div class="row">
    <input id="serial" type="text" placeholder="Scan or type serial...">
    <button id="scanBtn" type="button" class="ghost" title="Scan barcode">Scan</button>
    <button id="stopBtn" type="button" class="secondary" style="display:none;">Stop</button>
  </div>

  <video id="video" playsinline muted></video>
  <div id="scanMsg" class="tips"></div>

  <!-- Camera manual controls (shown only if supported) -->
  <div id="camToolbar" class="camToolbar">
    <div class="group" id="zoomGroup" style="display:none;">
      <label for="zoomRange">Zoom</label>
      <input id="zoomRange" type="range" min="1" max="1" step="0.1" value="1">
      <span id="zoomVal" class="tips">1x</span>
    </div>
    <div class="group" id="afGroup" style="display:none;">
      <button id="afSingleBtn" type="button" class="ghost" title="Autofocus single-shot">AF (single)</button>
    </div>
    <div class="group" id="torchGroup" style="display:none;">
      <button id="torchBtn" type="button" class="ghost" title="Toggle torch">Torch: Off</button>
    </div>
    <div class="group" id="focusDistGroup" style="display:none;">
      <label for="focusRange">Focus</label>
      <input id="focusRange" type="range" min="0" max="1" step="0.01" value="0.5">
    </div>
  </div>

  <label>Photo</label>
  <input id="photo" type="file" accept="image/*" capture="environment">
  <div id="fileInfo" class="fileinfo">
    <span class="name"></span> <span class="size tips"></span>
    <div class="preview"><img id="previewImg" alt="Preview"></div>
  </div>

  <div class="actions">
    <button id="saveBtn">Save as JPG</button>
    <button id="resetBtn" class="secondary">Reset</button>
  </div>

  <div id="msg"></div>
</div>

<script>
/* ===== Elements ===== */
const serialEl = document.getElementById('serial');
const scanBtn  = document.getElementById('scanBtn');
const stopBtn  = document.getElementById('stopBtn');
const videoEl  = document.getElementById('video');
const scanMsg  = document.getElementById('scanMsg');
let   photoInp = document.getElementById('photo');
const saveBtn  = document.getElementById('saveBtn');
const resetBtn = document.getElementById('resetBtn');
const msgEl    = document.getElementById('msg');

const fileInfoEl = document.getElementById('fileInfo');
const fileNameEl = fileInfoEl.querySelector('.name');
const fileSizeEl = fileInfoEl.querySelector('.size');
const previewImg = document.getElementById('previewImg');

/* Camera controls */
const camToolbar   = document.getElementById('camToolbar');
const zoomGroup    = document.getElementById('zoomGroup');
const zoomRange    = document.getElementById('zoomRange');
const zoomVal      = document.getElementById('zoomVal');
const afGroup      = document.getElementById('afGroup');
const afSingleBtn  = document.getElementById('afSingleBtn');
const torchGroup   = document.getElementById('torchGroup');
const torchBtn     = document.getElementById('torchBtn');
const focusDistGroup = document.getElementById('focusDistGroup');
const focusRange   = document.getElementById('focusRange');

let stream=null, detector=null, running=false, loopId=null, canvas=null, ctx=null;
let busy=false, currentPreviewUrl=null, waitingCapture=false;
let track=null, caps=null, settings=null;
let torchOn=false;

/* ===== Helpers ===== */
function show(ok,t){ msgEl.style.color=ok?'#0a0':'#d00'; msgEl.textContent=t||''; }
function safeSerial(s){ return (s||'').trim().replace(/\s+/g,'').replace(/[^A-Za-z0-9_-]/g,''); }
function humanSize(bytes){
  if (!bytes && bytes !== 0) return '';
  const units = ['B','KB','MB','GB']; let i=0; let n=bytes;
  while (n>=1024 && i<units.length-1){ n/=1024; i++; }
  return n.toFixed(n<10 && i>0 ? 1 : 0) + ' ' + units[i];
}

/* ===== Scanner with manual focus controls ===== */
async function startScan(){
  if(!('BarcodeDetector' in window)){
    show(false,'Barcode scanning not supported; type the serial.');
    return;
  }
  try {
    detector = new BarcodeDetector({ formats:['qr_code','code_128','code_39','ean_13','ean_8','upc_a','upc_e','itf','codabar'] });
  } catch(e) {
    show(false,'Scanner init failed: '+e);
    return;
  }

  const constraints = {
    video: {
      facingMode: { ideal: 'environment' },
      width:  { ideal: 1920 },
      height: { ideal: 1080 },
      focusMode: 'continuous',
      advanced: [{ focusMode: 'continuous' }]
    },
    audio: false
  };

  try {
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    videoEl.srcObject = stream;
    await videoEl.play();
    if (videoEl.readyState < 2) await new Promise(res => videoEl.onloadedmetadata = res);

    /* Track + capabilities */
    track = stream.getVideoTracks()[0];
    settings = track.getSettings ? track.getSettings() : {};
    caps = track.getCapabilities ? track.getCapabilities() : {};

    // Try to reinforce AF
    try { await track.applyConstraints({ advanced: [{ focusMode: 'continuous' }] }); } catch(_){}

    // Build detection canvas from real video size
    const vw = videoEl.videoWidth  || 1280;
    const vh = videoEl.videoHeight || 720;
    canvas = document.createElement('canvas');
    canvas.width = vw; canvas.height = vh;
    ctx = canvas.getContext('2d', { willReadFrequently:true });

    // UI
    videoEl.style.display = 'block';
    scanBtn.style.display = 'none';
    stopBtn.style.display = 'inline-block';
    scanMsg.textContent = 'Scanning… Tap video to focus.';
    setTimeout(() => videoEl.scrollIntoView({ behavior:'smooth', block:'start' }), 50);
    running = true;
    loopScan();

    // Setup manual controls if supported
    setupCameraControls();

  } catch(e){
    const hint = (location.protocol==='file:'? 'Opened via file:// — camera blocked. Host over HTTPS.' : 'Permission blocked; allow Camera in site settings.');
    show(false,'Camera error: '+(e && e.name ? e.name : e)+'. '+hint);
  }
}

function loopScan(){
  if(!running) return;
  try { ctx.drawImage(videoEl, 0, 0, canvas.width, canvas.height); } catch(e){}
  detector.detect(canvas).then(results => {
    if(results && results.length){
      const code = (results[0].rawValue || results[0].displayValue || '').trim();
      if(code){
        serialEl.value = code;
        stopScan(true);
        show(true,'Scanned: '+code);
      }
    }
    loopId = requestAnimationFrame(loopScan);
  }).catch(() => { loopId = requestAnimationFrame(loopScan); });
}

function stopScan(hide){
  running = false;
  if(loopId) { cancelAnimationFrame(loopId); loopId=null; }
  if(stream){
    try{ stream.getTracks().forEach(t=>t.stop()); }catch(_){}
    stream=null; track=null; caps=null; settings=null;
  }
  if(hide){
    videoEl.style.display='none';
    scanMsg.textContent='';
  }
  camToolbar.style.display = 'none';
  scanBtn.style.display='inline-block';
  stopBtn.style.display='none';
  if(canvas){ try{ canvas.width = canvas.height = 0; }catch(_){}
    canvas = null; ctx = null;
  }
  torchOn = false;
}

/* ===== Manual camera controls ===== */
function setupCameraControls(){
  if (!track || !track.getCapabilities) return;

  const c = track.getCapabilities();
  camToolbar.style.display = 'flex';

  // Zoom
  if (c.zoom) {
    const min = c.zoom.min || 1, max = c.zoom.max || 1, step = c.zoom.step || 0.1;
    zoomRange.min = min; zoomRange.max = max; zoomRange.step = step;
    const s = track.getSettings ? track.getSettings() : {};
    const cur = s.zoom || 1;
    zoomRange.value = cur;
    zoomVal.textContent = `${cur.toFixed(1)}x`;
    zoomGroup.style.display = 'flex';

    zoomRange.oninput = async () => {
      const v = Number(zoomRange.value);
      zoomVal.textContent = `${v.toFixed(1)}x`;
      try { await track.applyConstraints({ advanced: [{ zoom: v }] }); } catch(_){}
    };
  } else {
    zoomGroup.style.display = 'none';
  }

  // Torch
  if (c.torch) {
    torchGroup.style.display = 'flex';
    torchBtn.onclick = async () => {
      torchOn = !torchOn;
      try { await track.applyConstraints({ advanced: [{ torch: torchOn }] }); } catch(_){ torchOn = !torchOn; }
      torchBtn.textContent = `Torch: ${torchOn ? 'On' : 'Off'}`;
    };
  } else {
    torchGroup.style.display = 'none';
  }

  // AF single-shot
  const hasAFSingle = c.focusMode && Array.isArray(c.focusMode) && c.focusMode.includes('single-shot');
  if (hasAFSingle) {
    afGroup.style.display = 'flex';
    afSingleBtn.onclick = async () => {
      try { await track.applyConstraints({ advanced: [{ focusMode: 'single-shot' }] }); } catch(_){}
    };
  } else {
    afGroup.style.display = 'none';
  }

  // Manual focus distance
  if (c.focusDistance && typeof c.focusDistance.min === 'number' && typeof c.focusDistance.max === 'number') {
    focusDistGroup.style.display = 'flex';
    const min = c.focusDistance.min;
    const max = c.focusDistance.max;
    focusRange.min = 0; focusRange.max = 1; focusRange.step = 0.01;

    // map slider 0..1 to focusDistance min..max
    const applyFocus = async (norm) => {
      const dist = min + norm * (max - min);
      try { await track.applyConstraints({ advanced: [{ focusMode: 'manual', focusDistance: dist }] }); } catch(_){}
    };
    focusRange.oninput = () => applyFocus(Number(focusRange.value));
  } else {
    focusDistGroup.style.display = 'none';
  }

  // Tap to focus: use pointsOfInterest if supported; else map to focusDistance if present; else trigger single-shot AF
  videoEl.onclick = async (ev) => {
    if (!track) return;
    const rect = videoEl.getBoundingClientRect();
    const x = (ev.clientX - rect.left) / rect.width;   // 0..1
    const y = (ev.clientY - rect.top)  / rect.height;  // 0..1

    let tried = false;

    // pointsOfInterest (best)
    if (c.pointsOfInterest) {
      try {
        await track.applyConstraints({ advanced: [{ pointsOfInterest: [{ x, y }] }] });
        tried = true;
      } catch(_) {}
    }

    // manual focus distance fallback: near if lower half, far if upper (or map by x)
    if (!tried && c.focusDistance && typeof c.focusDistance.min === 'number' && typeof c.focusDistance.max === 'number') {
      const norm = 1 - y; // tap lower = closer, upper = farther (tweakable)
      const dist = c.focusDistance.min + norm * (c.focusDistance.max - c.focusDistance.min);
      try {
        await track.applyConstraints({ advanced: [{ focusMode: 'manual', focusDistance: dist }] });
        tried = true;
      } catch(_) {}
    }

    // single-shot AF as last resort
    if (!tried && c.focusMode && c.focusMode.includes('single-shot')) {
      try { await track.applyConstraints({ advanced: [{ focusMode: 'single-shot' }] }); } catch(_) {}
    }
  };
}

/* ===== Android photo picker quirks ===== */
function onPhotoClick(){ stopScan(true); waitingCapture = true; }
function onPhotoChange(){ waitingCapture = false; renderSelectedFile(); }
function onVisibilityChange(){
  if (!document.hidden && waitingCapture){
    waitingCapture = false;
    let tries = 0;
    (function poll(){
      tries++;
      if (photoInp.files && photoInp.files[0]) { renderSelectedFile(); return; }
      if (tries > 20) return;
      setTimeout(poll, 100);
    })();
  }
}
document.addEventListener('visibilitychange', onVisibilityChange);

function renderSelectedFile(){
  if (currentPreviewUrl){ try { URL.revokeObjectURL(currentPreviewUrl); } catch(_){ } currentPreviewUrl = null; }
  const f = photoInp.files && photoInp.files[0];
  if (!f){
    fileInfoEl.style.display = 'none';
    previewImg.removeAttribute('src');
    fileNameEl.textContent = '';
    fileSizeEl.textContent = '';
    return;
  }
  const name = f.name && f.name !== 'image.jpg' ? f.name : '(new photo)';
  fileNameEl.textContent = name;
  fileSizeEl.textContent = '· ' + humanSize(f.size);
  currentPreviewUrl = URL.createObjectURL(f);
  previewImg.onload = () => { try { URL.revokeObjectURL(currentPreviewUrl); } catch(_){ } currentPreviewUrl = null; };
  previewImg.src = currentPreviewUrl;
  fileInfoEl.style.display = 'block';
}

/* ===== Save (downscale + memory-safe) ===== */
async function saveAsJpgSerial(){
  if (busy) return;
  busy = true; saveBtn.disabled = true;

  const raw = (serialEl.value||'').trim();
  const f   = photoInp.files && photoInp.files[0];

  if(!raw){ alert('Enter the serial first.'); serialEl.focus(); busy=false; saveBtn.disabled=false; return; }
  if(!f){ alert('Take/choose a photo.'); photoInp.focus(); busy=false; saveBtn.disabled=false; return; }

  stopScan(false); // free camera memory

  let bitmap=null, dlUrl=null;
  try {
    try {
      bitmap = await createImageBitmap(f);
    } catch {
      const objURL = URL.createObjectURL(f);
      bitmap = await new Promise((resolve,reject)=>{
        const img=new Image(); img.onload=()=>resolve(img); img.onerror=reject; img.src=objURL;
      }).finally(()=>{ try{ URL.revokeObjectURL(objURL); }catch(_){ } });
    }

    // Downscale (long side ≤ 1600)
    const MAX = 1600;
    let w = bitmap.naturalWidth  || bitmap.width  || 1280;
    let h = bitmap.naturalHeight || bitmap.height || 720;
    if (w >= h && w > MAX) { h = Math.round(h * (MAX / w)); w = MAX; }
    else if (h > w && h > MAX) { w = Math.round(w * (MAX / h)); h = MAX; }

    const cnv = document.createElement('canvas');
    cnv.width = w; cnv.height = h;
    const cctx = cnv.getContext('2d', { willReadFrequently:true });
    cctx.drawImage(bitmap, 0, 0, w, h);
    try { if (bitmap.close) bitmap.close(); } catch(_) {}
    bitmap = null;

    const jpegBlob = await new Promise((res, rej) =>
      cnv.toBlob(b => b ? res(b) : rej(new Error('JPEG encode failed')), 'image/jpeg', 0.85)
    );
    try { cnv.width = cnv.height = 0; } catch(_){}

    const outName = (safeSerial(raw) || 'photo') + '.jpg';
    dlUrl = URL.createObjectURL(jpegBlob);
    const a = document.createElement('a');
    a.href = dlUrl; a.download = outName;
    document.body.appendChild(a); a.click(); a.remove();
    try { URL.revokeObjectURL(dlUrl); } catch(_){}
    show(true, 'Saved as ' + outName + ' (downscaled JPEG).');

  } catch (e) {
    show(false, 'Save failed: ' + (e && e.message ? e.message : e));
  } finally {
    if (currentPreviewUrl){ try { URL.revokeObjectURL(currentPreviewUrl); } catch(_){ } currentPreviewUrl = null; }
    previewImg.removeAttribute('src');
    fileInfoEl.style.display = 'none';
    fileNameEl.textContent = '';
    fileSizeEl.textContent = '';

    const newInp = photoInp.cloneNode();
    photoInp.parentNode.replaceChild(newInp, photoInp);
    photoInp = newInp;
    photoInp.addEventListener('click', onPhotoClick);
    photoInp.addEventListener('change', onPhotoChange);
    photoInp.addEventListener('input', onPhotoChange);

    serialEl.value = '';
    setTimeout(() => serialEl.focus(), 200);

    busy=false; saveBtn.disabled=false;
  }
}

/* ===== Manual Reset ===== */
function resetAll(){
  stopScan(true);
  serialEl.value = '';

  if (currentPreviewUrl){ try { URL.revokeObjectURL(currentPreviewUrl); } catch(_){ } currentPreviewUrl = null; }
  previewImg.removeAttribute('src');
  fileInfoEl.style.display = 'none';
  fileNameEl.textContent = '';
  fileSizeEl.textContent = '';

  const newInp = photoInp.cloneNode();
  photoInp.parentNode.replaceChild(newInp, photoInp);
  photoInp = newInp;
  photoInp.addEventListener('click', onPhotoClick);
  photoInp.addEventListener('change', onPhotoChange);
  photoInp.addEventListener('input', onPhotoChange);

  show(true,'');
  setTimeout(() => serialEl.focus(), 200);
}

/* ===== Wire up ===== */
scanBtn.addEventListener('click', startScan);
stopBtn.addEventListener('click', () => stopScan(true));
saveBtn.addEventListener('click', saveAsJpgSerial);
resetBtn.addEventListener('click', resetAll);

// file input handlers (Android quirks)
photoInp.addEventListener('click', onPhotoClick);
photoInp.addEventListener('change', onPhotoChange);
photoInp.addEventListener('input', onPhotoChange);

// initial focus
setTimeout(() => serialEl.focus(), 300);
</script>
</body>
</html>
