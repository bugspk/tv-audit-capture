<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>TV Audit – Scan from Photo & Save as &lt;serial&gt;.jpg</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root { --pad:14px; --muted:#555; --btn:#2d6cdf; --ok:#0a0; --err:#d00; }
  body { font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin:0; }
  .wrap { max-width:520px; margin:auto; padding:var(--pad); }
  h2 { margin:0 0 10px 0; }
  label { font-weight:600; display:block; margin:12px 0 6px; }
  input[type="text"] { width:100%; padding:10px; font-size:18px; border:1px solid #ccc; border-radius:8px; }
  button { padding:10px 14px; font-size:16px; border:0; border-radius:10px; background:var(--btn); color:#fff; }
  button.secondary { background:#777; }
  button.ghost { background:#eee; color:#222; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .actions { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:10px; }
  #msg { margin-top:10px; font-size:14px; }
  .tips { margin-top:12px; color:var(--muted); font-size:12px; }
  details { margin:6px 0 10px; }
  summary { cursor:pointer; color:#333; font-weight:600; }
  summary::marker { color:#888; }
  ol { color:#555; line-height:1.45; padding-left:20px; margin:8px 0 0; }
  .fileinfo { margin-top:8px; font-size:13px; color:#333; display:none; }
  .fileinfo .name { font-weight:600; }
  .preview { margin-top:6px; }
  .preview img { max-width:100%; max-height:160px; border-radius:8px; display:block; }
</style>
<!-- html5-qrcode for decoding barcodes from an image file -->
<script src="https://unpkg.com/html5-qrcode"></script>
</head>
<body>
<div class="wrap">
  <h2>Serial Scanner v0.95</h2>

  <details>
    <summary>How to use (tap to expand)</summary>
    <ol>
      <li>Tap <b>Scan from Photo</b> → native camera opens → capture the barcode image (native autofocus).</li>
      <li>We <b>downscale</b> the captured photo and decode locally to fill <b>Serial</b>.</li>
      <li>Take the separate <b>Audit Photo</b> (the TV picture), verify preview, then <b>Save as JPG</b> (named <code>&lt;serial&gt;.jpg</code>).</li>
      <li>Upload JPGs to Google Drive <code>YYYY_MM</code> later; run your Sheet’s Insert/Update.</li>
    </ol>
  </details>

  <label>Serial</label>
  <div class="row">
    <input id="serial" type="text" placeholder="Scan or type serial...">
    <button id="scanFromPhotoBtn" type="button" class="ghost">Scan from Photo</button>
    <!-- hidden file input used for barcode scan (opens native camera) -->
    <input id="scanPhoto" type="file" accept="image/*" capture="environment" style="display:none">
  </div>
  <div id="reader" style="display:none;"></div>

  <label>Audit Photo</label>
  <input id="photo" type="file" accept="image/*" capture="environment">
  <div id="fileInfo" class="fileinfo">
    <span class="name"></span> <span class="size tips"></span>
    <div class="preview"><img id="previewImg" alt="Preview"></div>
  </div>

  <div class="actions">
    <button id="saveBtn">Save as JPG</button>
    <button id="resetBtn" class="secondary">Reset</button>
  </div>

  <div id="msg"></div>
</div>

<script>
/* ===== Elements ===== */
const serialEl = document.getElementById('serial');
const scanFromPhotoBtn = document.getElementById('scanFromPhotoBtn');
let   scanPhotoInput   = document.getElementById('scanPhoto'); // will be replaced to reset between scans
let   photoInp         = document.getElementById('photo');     // will be replaced to free memory
const saveBtn  = document.getElementById('saveBtn');
const resetBtn = document.getElementById('resetBtn');
const msgEl    = document.getElementById('msg');

const fileInfoEl = document.getElementById('fileInfo');
const fileNameEl = fileInfoEl.querySelector('.name');
const fileSizeEl = fileInfoEl.querySelector('.size');
const previewImg = document.getElementById('previewImg');

let busy=false, currentPreviewUrl=null;
let waitingCaptureScan=false, waitingCapturePhoto=false;

// Reuse a single Html5Qrcode instance to avoid reloading WASM/code repeatedly
const scanner = new Html5Qrcode("reader");

/* ===== Helpers ===== */
function show(ok,t){ msgEl.style.color=ok?'#0a0':'#d00'; msgEl.textContent=t||''; }
function safeSerial(s){ return (s||'').trim().replace(/\s+/g,'').replace(/[^A-Za-z0-9_-]/g,''); }
function humanSize(bytes){
  if (!bytes && bytes !== 0) return '';
  const units = ['B','KB','MB','GB']; let i=0; let n=bytes;
  while (n>=1024 && i<units.length-1){ n/=1024; i++; }
  return n.toFixed(n<10 && i>0 ? 1 : 0) + ' ' + units[i];
}

/* Downscale a captured image to a smaller JPEG Blob (memory friendly) */
async function compressToJpegBlob(file, maxLongSide=1280, quality=0.85){
  // Prefer createImageBitmap with resize props if supported
  try {
    // Some browsers support resize options directly:
    // const bmp = await createImageBitmap(file, { resizeWidth: maxLongSide, resizeHeight: maxLongSide, resizeQuality: 'high' });
    // But we'll do manual scaling for widest compatibility.
    const bmp = await createImageBitmap(file);
    let w = bmp.naturalWidth || bmp.width || 1280;
    let h = bmp.naturalHeight || bmp.height || 720;
    if (w >= h && w > maxLongSide) { h = Math.round(h * (maxLongSide / w)); w = maxLongSide; }
    else if (h > w && h > maxLongSide) { w = Math.round(w * (maxLongSide / h)); h = maxLongSide; }

    // OffscreenCanvas if available (saves some memory), fallback to regular canvas
    let cnv, ctx;
    if (typeof OffscreenCanvas === 'function'){
      cnv = new OffscreenCanvas(w, h);
      ctx = cnv.getContext('2d', { willReadFrequently: true });
    } else {
      cnv = document.createElement('canvas');
      cnv.width = w; cnv.height = h;
      ctx = cnv.getContext('2d', { willReadFrequently: true });
    }
    ctx.drawImage(bmp, 0, 0, w, h);
    if (bmp.close) try { bmp.close(); } catch(_) {}

    const blob = await new Promise((res, rej) => {
      // OffscreenCanvas uses convertToBlob; HTMLCanvas uses toBlob
      if (cnv.convertToBlob) {
        cnv.convertToBlob({ type: 'image/jpeg', quality }).then(res).catch(rej);
      } else {
        cnv.toBlob(b => b ? res(b) : rej(new Error('toBlob failed')), 'image/jpeg', quality);
      }
    });

    // Free canvas memory
    try { cnv.width = 0; cnv.height = 0; } catch(_) {}
    return blob;

  } catch (e) {
    // Fallback: decode via <img>
    const objURL = URL.createObjectURL(file);
    try {
      const img = await new Promise((resolve, reject) => {
        const im = new Image();
        im.onload = () => resolve(im);
        im.onerror = reject;
        im.src = objURL;
      });
      let w = img.naturalWidth || 1280;
      let h = img.naturalHeight || 720;
      if (w >= h && w > maxLongSide) { h = Math.round(h * (maxLongSide / w)); w = maxLongSide; }
      else if (h > w && h > maxLongSide) { w = Math.round(w * (maxLongSide / h)); h = maxLongSide; }

      const cnv = document.createElement('canvas');
      cnv.width = w; cnv.height = h;
      const ctx = cnv.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(img, 0, 0, w, h);

      const blob = await new Promise((res, rej) =>
        cnv.toBlob(b => b ? res(b) : rej(new Error('toBlob failed')), 'image/jpeg', quality)
      );
      try { cnv.width = cnv.height = 0; } catch(_) {}
      return blob;
    } finally {
      try { URL.revokeObjectURL(objURL); } catch(_) {}
    }
  }
}

/* ===== Scan from Photo (native camera capture) ===== */
scanFromPhotoBtn.addEventListener('click', () => {
  waitingCaptureScan = true;
  scanPhotoInput.click();
});

async function handleScanPhotoFile(file){
  if (!file) return;
  try {
    // 1) Downscale the captured file BEFORE decoding (prevents low-memory)
    const smallBlob = await compressToJpegBlob(file, 1280, 0.85);
    // html5-qrcode expects a File or Blob; use a File with a tiny name
    const tinyFile = new File([smallBlob], 'scan.jpg', { type: 'image/jpeg' });

    // 2) Decode from the smaller file
    const result = await scanner.scanFileV2(tinyFile, false);
    const code = (result && result.decodedText || '').trim();

    if (code){
      serialEl.value = code;
      show(true, 'Scanned from photo: ' + code);
    } else {
      show(false, 'No barcode found in the selected photo.');
    }
  } catch (e) {
    show(false, 'Scan from photo failed: ' + (e && e.message ? e.message : e));
  } finally {
    // 3) Reset the scan input to free memory + allow re-pick; rewire listener
    const newInp = scanPhotoInput.cloneNode();
    scanPhotoInput.parentNode.replaceChild(newInp, scanPhotoInput);
    scanPhotoInput = newInp;
    wireScanPhotoHandlers();
  }
}

/* Android quirk handling for scan input */
function onScanPhotoChange(){
  waitingCaptureScan = false;
  const f = scanPhotoInput.files && scanPhotoInput.files[0];
  if (f) handleScanPhotoFile(f);
}
function onVisibilityChange(){
  if (!document.hidden) {
    if (waitingCaptureScan){
      waitingCaptureScan = false;
      let tries = 0;
      (function poll(){
        tries++;
        if (scanPhotoInput.files && scanPhotoInput.files[0]) { handleScanPhotoFile(scanPhotoInput.files[0]); return; }
        if (tries > 20) return;
        setTimeout(poll, 100);
      })();
    }
    if (waitingCapturePhoto){
      waitingCapturePhoto = false;
      let tries = 0;
      (function poll2(){
        tries++;
        if (photoInp.files && photoInp.files[0]) { renderSelectedAuditPhoto(); return; }
        if (tries > 20) return;
        setTimeout(poll2, 100);
      })();
    }
  }
}
document.addEventListener('visibilitychange', onVisibilityChange);
function wireScanPhotoHandlers(){
  scanPhotoInput.addEventListener('change', onScanPhotoChange);
}
wireScanPhotoHandlers();

/* ===== Audit Photo: preview name/size + thumbnail (with Android quirks) ===== */
function onAuditPhotoClick(){ waitingCapturePhoto = true; }
function onAuditPhotoChange(){ waitingCapturePhoto = false; renderSelectedAuditPhoto(); }

function renderSelectedAuditPhoto(){
  if (currentPreviewUrl){ try { URL.revokeObjectURL(currentPreviewUrl); } catch(_){ } currentPreviewUrl = null; }
  const f = photoInp.files && photoInp.files[0];
  if (!f){
    fileInfoEl.style.display = 'none';
    previewImg.removeAttribute('src');
    fileNameEl.textContent = '';
    fileSizeEl.textContent = '';
    return;
  }
  const name = f.name && f.name !== 'image.jpg' ? f.name : '(new photo)';
  fileNameEl.textContent = name;
  fileSizeEl.textContent = '· ' + humanSize(f.size);
  currentPreviewUrl = URL.createObjectURL(f);
  previewImg.onload = () => { try { URL.revokeObjectURL(currentPreviewUrl); } catch(_){ } currentPreviewUrl = null; };
  previewImg.src = currentPreviewUrl;
  fileInfoEl.style.display = 'block';
}

/* ===== Save (downscale + memory-safe) ===== */
async function saveAsJpgSerial(){
  if (busy) return;
  busy = true; saveBtn.disabled = true;

  const raw = (serialEl.value||'').trim();
  const f   = photoInp.files && photoInp.files[0];

  if(!raw){ alert('Enter the serial first (or use Scan from Photo).'); serialEl.focus(); busy=false; saveBtn.disabled=false; return; }
  if(!f){ alert('Take/choose an audit photo.'); photoInp.focus(); busy=false; saveBtn.disabled=false; return; }

  let bitmap=null, dlUrl=null;
  try {
    try {
      bitmap = await createImageBitmap(f);
    } catch {
      const objURL = URL.createObjectURL(f);
      bitmap = await new Promise((resolve,reject)=>{
        const img=new Image(); img.onload=()=>resolve(img); img.onerror=reject; img.src=objURL;
      }).finally(()=>{ try{ URL.revokeObjectURL(objURL); }catch(_){ } });
    }

    // Downscale audit photo too (long side ≤ 1600)
    const MAX = 1600;
    let w = bitmap.naturalWidth  || bitmap.width  || 1280;
    let h = bitmap.naturalHeight || bitmap.height || 720;
    if (w >= h && w > MAX) { h = Math.round(h * (MAX / w)); w = MAX; }
    else if (h > w && h > MAX) { w = Math.round(w * (MAX / h)); h = MAX; }

    const cnv = document.createElement('canvas');
    cnv.width = w; cnv.height = h;
    const cctx = cnv.getContext('2d', { willReadFrequently: true });
    cctx.drawImage(bitmap, 0, 0, w, h);
    try { if (bitmap.close) bitmap.close(); } catch(_) {}
    bitmap = null;

    const jpegBlob = await new Promise((res, rej) =>
      cnv.toBlob(b => b ? res(b) : rej(new Error('JPEG encode failed')), 'image/jpeg', 0.85)
    );
    try { cnv.width = cnv.height = 0; } catch(_){}

    const outName = (safeSerial(raw) || 'photo') + '.jpg';
    dlUrl = URL.createObjectURL(jpegBlob);
    const a = document.createElement('a');
    a.href = dlUrl; a.download = outName;
    document.body.appendChild(a); a.click(); a.remove();
    try { URL.revokeObjectURL(dlUrl); } catch(_){}
    show(true, 'Saved as ' + outName + ' (downscaled JPEG).');

  } catch (e) {
    show(false, 'Save failed: ' + (e && e.message ? e.message : e));
  } finally {
    if (currentPreviewUrl){ try { URL.revokeObjectURL(currentPreviewUrl); } catch(_){ } currentPreviewUrl = null; }
    previewImg.removeAttribute('src');
    fileInfoEl.style.display = 'none';
    fileNameEl.textContent = '';
    fileSizeEl.textContent = '';

    const newInp = photoInp.cloneNode();
    photoInp.parentNode.replaceChild(newInp, photoInp);
    photoInp = newInp;
    photoInp.addEventListener('click', onAuditPhotoClick);
    photoInp.addEventListener('change', onAuditPhotoChange);
    photoInp.addEventListener('input', onAuditPhotoChange);

    serialEl.value = '';
    setTimeout(() => serialEl.focus(), 200);

    busy=false; saveBtn.disabled=false;
  }
}

/* ===== Manual Reset ===== */
function resetAll(){
  serialEl.value = '';

  if (currentPreviewUrl){ try { URL.revokeObjectURL(currentPreviewUrl); } catch(_){ } currentPreviewUrl = null; }
  previewImg.removeAttribute('src');
  fileInfoEl.style.display = 'none';
  fileNameEl.textContent = '';
  fileSizeEl.textContent = '';

  const newInp = photoInp.cloneNode();
  photoInp.parentNode.replaceChild(newInp, photoInp);
  photoInp = newInp;
  photoInp.addEventListener('click', onAuditPhotoClick);
  photoInp.addEventListener('change', onAuditPhotoChange);
  photoInp.addEventListener('input', onAuditPhotoChange);

  show(true,'');
  setTimeout(() => serialEl.focus(), 200);
}

/* ===== Wire up ===== */
saveBtn.addEventListener('click', saveAsJpgSerial);
resetBtn.addEventListener('click', resetAll);

// audit photo handlers (Android quirks)
photoInp.addEventListener('click', () => { waitingCapturePhoto = true; });
photoInp.addEventListener('change', onAuditPhotoChange);
photoInp.addEventListener('input', onAuditPhotoChange);

// scan photo handlers (Android quirks)
function onScanPhotoClick(){ waitingCaptureScan = true; }
scanPhotoInput.addEventListener('change', onScanPhotoChange);
scanFromPhotoBtn.addEventListener('click', () => { onScanPhotoClick(); scanPhotoInput.click(); });

// initial focus
setTimeout(() => serialEl.focus(), 300);
</script>
</body>
</html>
